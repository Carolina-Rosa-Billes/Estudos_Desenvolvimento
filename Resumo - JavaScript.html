<meta charset="UTF-8">

<script> //Diz pro navegador que o conteúdo é javascript, não html.

    // É dinâmica, não precisa escrever se as variáveis são números, strings ou booleanos. Ele vê sozinho, e dá pra mudar o tipo se quiser.
    // Node JS é um aplicativo, instalação para rodar o JavaScript fora do navegador de um site, como no próprio editor de código.
    // Orientação a Objetos é um paradigma da programação que lida com as características (cor, peso, idade) e comportamentos (sorrir, amar, ler) dos objetos.
    // elemento._proto_ gera uma lista de todas as ações possíveis com aquele elemento.
    // Hoisting significa içar, é a capacidade de nomear elementos antes de declarar a função.
    // == é o igual do java, compara o conteúdo.
    // === compara o conteúdo e o formato.
    // != é o diferente do java, compara o conteúdo.
    // !== compara o conteúdo e o formato.
    // && é o E do java.
    // || é o OU do java.
    // !valor é a negação do valor, ele falso.
    // Linhas e colunas são entendidas no java. Se eu pedir apenas 10 colunas, o 11º caractere não vai ser aceito.
    // * e / transformam textos em números. Por exemplo “5” * 3 = 15.
    // incremento++ = o mesmo que “incremento = incremento + 1”, é um atalho.
    // 0 e strings vazias ("") são consideradas falsas.
    // Undefined aparece quando a variável não foi declarada.
    // Null aparece quando a variável foi declarada como vazia.
    // Control + C para o looping infinito.

    tipo-elemento._proto_ //No navegador, abre uma lista com todos os métodos disponíveis para aquele tipo de dado
    console.log("texto"); //Exibe o texto no console.
    document.write = `texto ${variavel} texto ${variavel}`; //Concetena textos e variáveis de um modo muito mais simples.

    document.write("texto"); //Cria um texto dentro do java.
    document.write("<br>"); //Quebra a linha, como se desse enter.
    document.write(3 + 3); //Escreve 6, os números fazem operações.
    document.write("3" + "3"); //Escreve 33, os números são strings.
    document.write("texto " + 3 + 3); //Escreve texto 33, concatena.
    document.write("texto " + (3 + 3)); //Escreve texto 6, faz operações.

    Math.round(numero); //Arredonda o resultado para o número mais próximo.
    Math.ceil(numero); //Arredonda o resultado para o número mais alto.
    Math.floor(numero); //Arredonda o resultado para o número mais baixo.
    Math.trunc(numero); //Desconsidera as casas decimais, pega só o número inteiro.
    Math.ramdon(); //Gera um número aleatório, como 0.3415… Para um número inteiro, basta multiplicar e arredondar.
    Math.PI //O mesmo que 3.14, para usar em círculos.
    nome.toUpperCase(); //Deixa todas as letras maiúsculas.

    new Date(); //Mostra a data atual.
    data.getUTCFullYear(); //Mostra o ano atual.
    data.getUTCMonth(); //Mostra o mês atual.
    data.getUTCDate(); //Mostra o dia atual.

    parseInt("3"); //Transforma o texto em número, torna apto pra operações.
    parseFloat("3.3"); //Transforma o texto em número decimal, torna apto pra operações.
    number(elemento); //Transforma o elemento em número, deixa de ser string.
    string(elemento); //Transforma o elemento em string, deixa de ser número.
    elemento.substring(numero_inicial, numero_final); //Exibe apenas um pedaço da string.
    isNaN(variavel); //Diz se é verdadeiro ou falso que a variável é um não número.
    typeof elemento === tipo_dado; //Analisa se o elemento é do tipo pedido, seja função, string, objeto...
    elemento.value; //Pega o valor de algo.
    elemento.validity.valid; //Diz a validade do elemento, se está de acordo com os parâmetros estabelecidos (true) ou não (false).
    elemento.validity.valueMissing; //Diz o preenchimento do elemento se ele está vazio (true) ou preenchido (false).
    elemento.onclick = acontecimento; //Faz o acontecimento quando o elemento é clicado.
    elemento.onkeydown = acontecimento; //Faz o acontecimento quando a tecla está pressionada.
    elemento.onkeyup = acontecimento; //Faz o acontecimento quando a tecla deixa de ser pressionada.
    elemento.addEventListener("click", acontecimento); //Gera um evento, um acontecimento quando o elemento é clicado.
    elemento.focus(); //Deixa o elemento em destaque.
    elemento.add[caracteristica]; //Adiciona uma característica no elemento.
    elemento.remove[caracteristica]; //Remove uma característica no elemento.
    return parametro; //Mostra o que foi pedido, como uma variável ou função.
    break; //Sai do looping.

    alert("texto"); //Cria um alerta, uma caixinha na página com o texto.
    prompt("texto"); //Cria uma proposta, uma caixinha na página com a pergunta pro usuário e espaço pra resposta, que é guardada como texto.
    document.querySelector("elemento"); //Traz pro java um elemento do html, como input ou botton. O elemento é .classe ou #id ou [data].
    document.querySelectorAll("elemento"); //Traz todos os elementos pro java, uma lista.

    var nome = "parametro"; //Cria uma variável. Sempre que chamar pelo nome, vai exibir o parâmetro dado. Pra chamar: document.write(nome);
    nome = "parametro novo"; //Redefine a variável, dá a ela um novo valor.

    const nome = "parametro"; //Cria uma variável que não pode ser mudada, precisa dar o valor quando criar.
    let nome = "parametro"; //Cria uma variável que pode ser mudada.

    var nome = [3, 4, 5,]; //Cria uma variável com vários parâmetros, uma array.
    nome.length; //Indica o número de elementos dentro do array.
    nome.classList[numero]; //Acessa o elemento do número, dentro da lista.
    nome.push(elemento); //Adiciona um elemento no fim do array.
    nome.pop(); //Remove o último elemento do array.
    nome.slice(primeiro_elemento, ultimo_elemento); //Pega um pedaço de um array. Se passar só um parâmetro, vai começar nele e ir até o final do array.
    nome.splice(numero_primeiro_removido, quantidade_removidos, elementos_substitutos); //Remove elementos do array e substitui por outros. Pode só remover ou só adicionar, também.
    primeiro_array.concat(segundo_array); //Cria um novo array concatenando ambos.

    function nome() //Cria uma função que faz o que eu quiser, como pular linhas, por exemplo. Pra chamar: nome();
        {acontecimento;}

    function nome(parametro) //Cria uma função adaptável que faz o que eu quiser. Pra chamar: nome(resultado);
        {acontecimento(parametro);}

    function nome(parametro1, parametro2) //Cria uma função com 2 parâmetros, que faz o que eu quiser. Pra chamar: nome(resultado);
        {acontecimento(parametro1 + parametro2);}

    function nome(parametro = estepe) //Cria uma função com estepe. Caso não seja declarado parâmetro, ele aparecerá.
        {acontecimento(parametro);}

    nome = function (parametro) {acontecimento}; //Expressão de função, ela simplificada. Não pode ser chamada anteriormente no código.
    nome = parametro => {acontecimento}; //Arrow function, ela simplificada. Não pode ser chamada anteriormente no código.

    setInterval(nomefunção, 1000) //Chama a função de tempos em tempos, nesse caso 1000 milisegundos, ou 1 segundo.

    parametro ? "acontecimento_true" : "acontecimento_false"; //O mesmo que o if, só que mais simples. É o operador ternário.

    if(parametro) //Faz o acontecimento, se o parâmetro for verdadeiro. Se for falso, não acontece nada.
        {acontecimento}

    else //Faz o acontecimento, se o parâmetro do if for falso.
        {acontecimento}

    while(parametro) //Faz o acontecimento enquanto o parâmetro for verdadeiro. Se for falso, para de acontecer.
        {acontecimento}

    var nome = "valor" //Faz o acontecimento enquanto o parâmetro for verdadeiro. O valor vai aumentando com o incremento, até tornar o parâmetro falso.
    while(parametro)
        {acontecimento;
        valor++;}

    for (variavel; parametro; incremento) //Faz o acontecimento enquanto o parâmetro for verdadeiro. O incremento vai alterando a variável, até tornar o parâmetro falso.
        {acontecimento}

    for (var nome in objeto) //Faz o acontecimento enquanto há dados no objeto, percorre ele inteiro.
            {acontecimento}

    nome_array.forEach(nome_funcao => {acontecimento}); //Faz um for simplificado.
    nome_array.map(acontecimento); //Cria um acontecimento com cada um dos elementos do array.
    nome_array.filter(parametro); //Filtra o array de acordo com o parâmetro. Se o parametro for verdadeiro, o filter exibe.
    nome_array.reduce((acum, atual) => atual + acum, 0); //Soma todos os elementos de um array.

    var nome = //Cria um objeto, como um array só que com vários tipos de dados.
        {elemento_1:"valor_elemento_1",
        elemento_2:"valor_elemento_2",
        elemento_3:"valor_elemento_3"}

    nome_objeto.nome_elemento; //Acessa um elemento no objeto.
    nome_objeto.novo_elemento = valor; //Adiciona um elemento no objeto. Se já existir algum com esse nome, o valor é atualizado.
    delete nome_objeto.nome_elemento; //Deleta um elemento no objeto.
    Object.keys(objeto); //Lista em um array todas as chaves, os elementos do objeto.
    Object.values(objeto); //Lista em um array todos os valores do objeto.
    Object.entries(objeto); //Lista em um array vários arrays com todos os elementos e valores do objeto.
    [...objeto[numero_indice].elemento]; //Pega os valores do elemento e coloca num array, espalhadinho. Pode ser usado pra concatenação.

    var nome = //Cria uma função dentro do objeto, nesse caso que incrementa o parametro no valor.
        {elemento: valor,
        nome_acao: function(parametro)
            {this.elemento += parametro}}

    function nome(elemento_1, elemento_2, elemento_3) //Cria um protótipo de objeto, para ser preenchido posteriormente e várias vezes.
        {this.elemento_1 = elemento_1
        this.elemento_2 = elemento_2
        this.elemento_3 = elemento_3};

    function nome(elemento_novo) //Cria um objeto que aproveita os elementos do protótipo, e adiciona novos.
        {nome_prototipo.call(this, elemento_1, elemento_2, elemento_3)
        this.elemento_novo = elemento_novo};

    var nome = Object.create(nome_prototipo) //Cria um objeto que aproveita os elementos do protótipo, e adiciona novos.
    console.log(nome.nome_elemento("valor_elemento"));

    var nome = new nome_prototipo("valor_1", "valor_2", "valor_3"); //Preenche o protótipo com as informações.
    nome_prototipo.prototype.nome_acao = {acontecimento}; //Adiciona algo no protótipo, de fora.
    Object.setPrototypeOf(objeto_herdeiro, objeto_original); //Transfere para o herdeiro as propriedades do original.

    class nome //Cria uma classe, que é como um objeto só que melhorado.
        {constructor(elemento_1, elemento_2, elemento_3)
            {this.elemento_1 = elemento_1
            this.elemento_2 = elemento_2
            this.elemento_3 = elemento_3}
        acao
            {acontecimento}};

    class nome_classe_nova extends nome_classe_antiga //Cria uma nova classe que aproveita os elementos da antiga, e adiciona novos.
        {constructor(elemento_1, elemento_2, elemento_3, elemento_novo)
            {super(elemento_1, elemento_2, elemento_3)
            this.elemento_novo = elemento_novo}};

    class nome //Cria uma classe com atributo privado. O elemento_1, depois de declarado, não pode mais ser alterado.
        #elemento_1
        {constructor(elemento_1, elemento_2, elemento_3)
            {this.#elemento_1 = elemento_1
            this.elemento_2 = elemento_2
            this.elemento_3 = elemento_3}
        acao
            {acontecimento}};

    class nome //Permite acessar o elemento privado, mostrá-lo em outras classes.
        #elemento_1
        {constructor(elemento_1, elemento_2, elemento_3)
            {this.#elemento_1 = elemento_1
            this.elemento_2 = elemento_2
            this.elemento_3 = elemento_3}
        get elemento_1()
            {return this.#elemento_1}};

    class nome //Permite acessar o elemento privado, modificá-lo.
        #elemento_1
        {constructor(elemento_1, elemento_2, elemento_3)
            {this.#elemento_1 = elemento_1
            this.elemento_2 = elemento_2
            this.elemento_3 = elemento_3}
        set elemento_1(novo_elemento_1)
            {this.#elemento_1 = novo_elemento_1}};

    nome_funcao.bind(nome_objeto); //Fornece um contexto para o this, faz com que ele saiba a que o isso se refere.

    var nome_desenho = variavel_do_canvas.getContext("2d"); //Diz o tipo de desenho que será posto na tela em branco, no canvas.
    nome_desenho.fillStyle = "cor"; //Diz a cor do desenho.
    nome_desenho.fillStroke = "cor"; //Diz a cor da borda.
    nome_desenho.strokeRect(x_inicial, y_inicial, x_final, y_final); //Diz o espaço da borda, nesse caso de um retângulo.
    nome_desenho.clearRect(x_inicial, y_inicial, x_final, y_final); //Limpa a tela, nesse caso retângulo, no espaço definido.

    nome_desenho.fillRect(x_inicial, y_inicial, x_final, y_final); //Diz o espaço do desenho, nesse caso retângulo, a partir do ponto 0x e 0y até 300x e 400y.
    nome_desenho.arc(x_inicial, y_inicial, raio, angulo_inicial, angulo_final * 3.14); //Desenha um círculo. Os ângulos precisam estar em radiano.
    
    nome_desenho.begin.Path(); //Inicia um desenho livre, linha por linha ou circular.
    nome_desenho.moveTo(x_inicial, y_inicial); //Diz o ponto inicial desse desenho.
    nome_desenho.lineTo(x_seguinte, y_seguinte); //Diz o ponto seguinte desse desenho.
    nome_desenho.fill(); //Diz para preencher o espaço desse desenho.

    parametro.pageX; // Diz o x da página.
    parametro.pageY; // Diz o y da página.
    parametro.offsetTop; //Diz respeito ao topo da tela, a parte branca.
    parametro.offsetBottom; //Diz respeito ao embaixo da tela, a parte branca.
    parametro.offsetRight; //Diz respeito ao lado direito da tela, a parte branca.
    parametro.offsetLeft; //Diz respeito ao lado esquerdo da tela, a parte branca.

</script>